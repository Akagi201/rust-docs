# 第一课 Rust 入门基本原理

视频地址：[Rust 入门基本原理](https://www.bilibili.com/video/BV1Pg411A7bx)

## 课程背景

今天晚上是我们 Rust 培养提高计划第二个阶段，我们第一个阶段刚切入到 Rust 这个方向，其实我们有很多东西是拿不准的，然后我们随时在做一些尝试，把我们认为重要东西然后以一种培养提高的方式，也就是说一种进阶的方式呈现给大家，但是我们在做的过程中发现可能这样的话知识太松散了，并不能很好带大家去真正学好 Rust.

我们想把课程做得更系统一点，计划在每个周日晚上，做成一个系列的课程让大家能够更系统地把 Rust 学习一下。周四晚上的话，我们可能会安排一些进阶类的知识，就是指这样一个组合。但是周四晚上我们是不固定的，周日晚上我们是个固定的这样一个方式作为大家 Rust 学习的一个陪伴。

学习编程语言，听的过程中一定要去练，这是我们必须强调的一个事情。我们整个课程体系开源在 [Github Discussions](https://github.com/wubx/rust-in-databend/discussions/17), 欢迎讨论。

现在 Rust 培养提高计划这个课程，是我自己在邀请业界的人在去做，如果有想共同学习的朋友欢迎一起加入进来，我现在想去招募一些学习委员和课代表这样的志愿者来跟我一起做相应的内容。我也希望通过我们几期的努力之后，我们能把这个课程做成一个系列出一本书，书的结构里面，将来我可能会把 Databend 本身的一些内容，比如他的代码工程结构，怎么去做他的代码扩展等加上去做成完整的一本书。我觉得也是在 Rust 推广步道里面有我们的一份力量。这是我在做这一系列课程的一个梦想，也可以说是一个小小的目标。

## 课程介绍

从这次公开课开始，接下来进入`Rust 新手入门`的一个系列课程。初步计划了以下这几块的内容来引导大家来入门 Rust，希望对大家能有所帮助，也希望大家能够通过这个系列的课程学有所获。

整个课程大概分成了八部分：

- 第一课: Rust 入门基本原理
- 第二课：类型系统
- 第三课：如何优雅地处理错误
- 第四课: Cargo 包管理
- 第五课：如何编写测试
- 第六课：理解宏机制
- 第七课：异步编程
- 第八课：不安全的 Rust

当你想使用 Rust 去实现复杂的功能的时候，重要的是我们要确保你对 Rust 的基础知识有一个深入的理解。

那么就像其他任何编程语言一样，当你开始以更复杂的方式来使用这门语言的时候，而不仅仅是在`main`方法里面去探索它的语法的时候，对语言本身概念的深入理解，会变得非常的重要。比如: Rust 的内存管理，Rust 所有权机制，Rust 借用规则，这些都是 Rust 这门语言独有的。充分理解这些概念是非常重要的。所以说，我们接下来会再次带领大家去入门 Rust 基本原理。那么第二课，我们会去讲 Rust 类型系统，我们将跳过 Rust 编程语言中的一些基本知识，而是直接深入了解不同类型在内存中的布局，比如说我们还会去讲 trait, trait bound 的来龙去脉等。第三课呢，我们会学习如何处理错误，其实我们除了写最简单的程序之外，其他一些复杂的程序都有可能存在 bug. 那么这一课呢，将学习这些错误，或者是这些 bug 的不同的一个方式以及每一种方法的一个优点和缺点。但是，其实 Rust 中错误处理的一个最佳实践，仍然是一个活跃的话题，在 Rust 生态当中并没有一个统一的方法。在这一课里面，我们会介绍一些基本的，或者是统一的处理错误的一些手段。那么第四课呢，我们会去介绍 cargo 包管理，Rust 是一种现代的编程语言，可提供高性能，可靠性和生产力。除了是一种出色的编程语言以外，Rust 还具有一个称为 cargo 的构建系统和软件包的一个管理器。那第五课呢，我们会去介绍如何编写测试。通过这一课程，我们将了解扩展 Rust 测试功能的各种方式。那么第六课呢，其实我们之前是讲过宏机制的，看前面几课大家的反馈我们来看这这次公开课又该怎样来讲。然后第七课异步编程，其实我们在之前的公开课花了大量的时间来讲，那么我们在一两次公开课里面再来回顾这个异步编程的，我计划的话 就是先了解同步编程模型，然后才能了解异步编程模型，然后我们将深入研究 Rust 中的异步实际的工作原理，可能花一两次公开课。然后第八课的话就是不安全的 Rust，也就是 Unsafe Rust 对吧，不安全代码其实是 Rust 为开发人员提供的一种机制，用于利用不变量，无论出于何种原因，编译器都无法检测，或者是说编译器都无法检查 Unsafe Rust 的这些代码，那么在这里呢，我们将研究 Unsafe 是如何做到这一点的，以及我们可以用 Unsafe Rust 来做些什么。

这是我们接下来可能在未来的两个多月的时间内的一套 Rust 新手的入门系列课程。如果大家对这次 Rust 新手入门系列课程有任何的意见的话都可以反馈给我们，我们会根据大家的反馈做到实时的更改和优化。

## 第一课 Rust 基本原理

接下来我们就开始今天第一课的讲解 Rust 入门的基本原理。

- Rust 内存管理
- 所有权机制
- 借用规则

今天我们将通过一些示例代码来建立一种心智模型，在代码示例里面，我们能够知道它在内存里面，是在堆还是在栈里，他是如何来进行一个管理和分配的。

### 理解 Rust 内存管理

Rust 是内存安全，没有 GC (垃圾回收) 的高效语言。使用 Rust，需要正确理解 Rust 管理内存的方式。

一提到内存管理方式，就离不开我们堆和栈的一个理解。关于栈空间和栈帧这些概念，我不会去念。我希望通过下面这段代码，大家能够画出栈帧调用的示意图。

```Rust
fn foo(x: u32) {
  let y = x;
  let z = 100;
}

fn main() {
  let x = 42;
  foo(x);
}
```

栈：属于操作系统的概念，操作系统负责管理栈空间，负责创建，释放栈帧。

我们在编写 C 语言时，需要手动申请和释放内存，在程序较大时，判断在何处编写释放内存的代码更是难上加难。这也是我们 Rust 出现的一个原因。那么 Rust 出现过后呢，我们就是要解决 C 语言的这样的一个痛点。Rust 只要能够编译通过，多数情况下没有内存问题。

作用域：

```Rust
fn main() {
  {
    // 大括号，一个独立的作用域
    let n = 33;
    println!("{}", n);
  } // 变量 n 在此失效，其绑定的数据 33 被释放
  // 此处无法再使用变量 n
  // println!("{}", n); // 编译错误
}
```

Rust 如何使用堆和栈

1. 栈适合存放存活时间短的数据。
2. 数据要存放于栈中，要求数据所属数据类型的大小是已知的。
3. 使用栈的效率要高于使用堆。
4. Rust 将哪些数据存放于栈中？
5. Rust 除了使用堆栈，还使用全局内存 (静态变量区和字面量区).
6. Rust 中允许使用 const 定义常量。常量将在编译期间直接以硬编码的方式内联 (inline) 插入到使用常量的地方。

Rust 位置表达式和值

1. 通过示例来理解变量，位置和值关系。
2. 理解变量的引用。
3. 位置和值与 Move 语义，Copy 语义的关联。

```Rust
fn main() {
  // s 是一个栈中的位置，保存了一个胖指针指向堆中的数据
  let mut s = "hello".to_string();
  // &s 产生一个位置，该位置中保存指向位置 n 的地址值
  println!("s: {:p}", &s);

  // 将 s 中的胖指针移给了 m, m 保存胖指针指向堆中的数据，s 变回未初始化的状态
  let m = s;
  println!("m: {:p}", &m);

  s = "world".to_string();
  println!("s: {:p}", &s); // s 值不变
}
```

### 理解 Rust 所有权机制

理解 Rust 的变量作用域

```Rust
fn main() {
  { // x 在这里无效，他尚未声明
    let x = "hello".to_string();
    println!("x-value: {}", x);
  } // 此作用域已结束，x 不再有效
  // 会自动调用 Drop trait 的 drop 函数来销毁该变量绑定在内存中的数据

  {
    let y = "hello"; // 字符串字面量，存放在全局内存中
    println!("{:p}", y);
  }
  let y = "hello";
  println!("{:p}", y);
}
```
